{"version":3,"sources":["useGestureEventsHandlersDefault.tsx"],"names":["Keyboard","Platform","runOnJS","useWorkletCallback","useBottomSheetInternal","ANIMATION_SOURCE","GESTURE_SOURCE","KEYBOARD_STATE","SCROLLABLE_TYPE","WINDOW_HEIGHT","clamp","snapPoint","dismissKeyboard","dismiss","useGestureEventsHandlersDefault","animatedPosition","animatedSnapPoints","animatedKeyboardState","animatedKeyboardHeight","animatedContainerHeight","animatedScrollableType","animatedHighestSnapPoint","animatedClosedPosition","animatedScrollableContentOffsetY","enableOverDrag","enablePanDownToClose","overDragResistanceFactor","isInTemporaryPosition","isScrollableRefreshable","animateToPosition","stopAnimation","handleOnStart","__","_","context","initialPosition","value","initialKeyboardState","isScrollablePositionLocked","handleOnActive","source","translationY","highestSnapPoint","SHOWN","lowestSnapPoint","SCROLLABLE","negativeScrollableContentOffset","draggedPosition","accumulatedDraggedPosition","clampedPosition","HANDLE","VIEW","resistedPosition","Math","sqrt","handleOnEnd","absoluteY","velocityY","isSheetAtHighestSnapPoint","GESTURE","isScrollable","UNDETERMINED","OS","snapPoints","slice","unshift","destinationPoint","wasGestureHandledByScrollView"],"mappings":"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","sourcesContent":["import { Keyboard, Platform } from 'react-native';\nimport { runOnJS, useWorkletCallback } from 'react-native-reanimated';\nimport { useBottomSheetInternal } from './useBottomSheetInternal';\nimport {\n  ANIMATION_SOURCE,\n  GESTURE_SOURCE,\n  KEYBOARD_STATE,\n  SCROLLABLE_TYPE,\n  WINDOW_HEIGHT,\n} from '../constants';\nimport type {\n  GestureEventsHandlersHookType,\n  GestureEventHandlerCallbackType,\n} from '../types';\nimport { clamp } from '../utilities/clamp';\nimport { snapPoint } from '../utilities/snapPoint';\n\ntype GestureEventContextType = {\n  initialPosition: number;\n  initialKeyboardState: KEYBOARD_STATE;\n  isScrollablePositionLocked: boolean;\n};\n\nconst dismissKeyboard = Keyboard.dismiss;\n\nexport const useGestureEventsHandlersDefault: GestureEventsHandlersHookType =\n  () => {\n    //#region variables\n    const {\n      animatedPosition,\n      animatedSnapPoints,\n      animatedKeyboardState,\n      animatedKeyboardHeight,\n      animatedContainerHeight,\n      animatedScrollableType,\n      animatedHighestSnapPoint,\n      animatedClosedPosition,\n      animatedScrollableContentOffsetY,\n      enableOverDrag,\n      enablePanDownToClose,\n      overDragResistanceFactor,\n      isInTemporaryPosition,\n      isScrollableRefreshable,\n      animateToPosition,\n      stopAnimation,\n    } = useBottomSheetInternal();\n    //#endregion\n\n    //#region gesture methods\n    const handleOnStart: GestureEventHandlerCallbackType<GestureEventContextType> =\n      useWorkletCallback(\n        function handleOnStart(__, _, context) {\n          // cancel current animation\n          stopAnimation();\n\n          // store current animated position\n          context.initialPosition = animatedPosition.value;\n          context.initialKeyboardState = animatedKeyboardState.value;\n\n          /**\n           * if the scrollable content is scrolled, then\n           * we lock the position.\n           */\n          if (animatedScrollableContentOffsetY.value > 0) {\n            context.isScrollablePositionLocked = true;\n          }\n        },\n        [\n          stopAnimation,\n          animatedPosition,\n          animatedKeyboardState,\n          animatedScrollableContentOffsetY,\n        ]\n      );\n    const handleOnActive: GestureEventHandlerCallbackType<GestureEventContextType> =\n      useWorkletCallback(\n        function handleOnActive(source, { translationY }, context) {\n          let highestSnapPoint = animatedHighestSnapPoint.value;\n\n          /**\n           * if keyboard is shown, then we set the highest point to the current\n           * position which includes the keyboard height.\n           */\n          if (\n            isInTemporaryPosition.value &&\n            context.initialKeyboardState === KEYBOARD_STATE.SHOWN\n          ) {\n            highestSnapPoint = context.initialPosition;\n          }\n\n          /**\n           * if current position is out of provided `snapPoints` and smaller then\n           * highest snap pont, then we set the highest point to the current position.\n           */\n          if (\n            isInTemporaryPosition.value &&\n            context.initialPosition < highestSnapPoint\n          ) {\n            highestSnapPoint = context.initialPosition;\n          }\n\n          const lowestSnapPoint = enablePanDownToClose\n            ? animatedContainerHeight.value\n            : animatedSnapPoints.value[0];\n\n          /**\n           * if scrollable is refreshable and sheet position at the highest\n           * point, then do not interact with current gesture.\n           */\n          if (\n            source === GESTURE_SOURCE.SCROLLABLE &&\n            isScrollableRefreshable.value &&\n            animatedPosition.value === highestSnapPoint\n          ) {\n            return;\n          }\n\n          /**\n           * a negative scrollable content offset to be subtracted from accumulated\n           * current position and gesture translation Y to allow user to drag the sheet,\n           * when scrollable position at the top.\n           * a negative scrollable content offset when the scrollable is not locked.\n           */\n          const negativeScrollableContentOffset =\n            (context.initialPosition === highestSnapPoint &&\n              source === GESTURE_SOURCE.SCROLLABLE) ||\n            !context.isScrollablePositionLocked\n              ? animatedScrollableContentOffsetY.value * -1\n              : 0;\n\n          /**\n           * an accumulated value of starting position with gesture translation y.\n           */\n          const draggedPosition = context.initialPosition + translationY;\n\n          /**\n           * an accumulated value of dragged position and negative scrollable content offset,\n           * this will insure locking sheet position when user is scrolling the scrollable until,\n           * they reach to the top of the scrollable.\n           */\n          const accumulatedDraggedPosition =\n            draggedPosition + negativeScrollableContentOffset;\n\n          /**\n           * a clamped value of the accumulated dragged position, to insure keeping the dragged\n           * position between the highest and lowest snap points.\n           */\n          const clampedPosition = clamp(\n            accumulatedDraggedPosition,\n            highestSnapPoint,\n            lowestSnapPoint\n          );\n\n          /**\n           * if scrollable position is locked and the animated position\n           * reaches the highest point, then we unlock the scrollable position.\n           */\n          if (\n            context.isScrollablePositionLocked &&\n            source === GESTURE_SOURCE.SCROLLABLE &&\n            animatedPosition.value === highestSnapPoint\n          ) {\n            context.isScrollablePositionLocked = false;\n          }\n\n          /**\n           * over-drag implementation.\n           */\n          if (enableOverDrag) {\n            if (\n              (source === GESTURE_SOURCE.HANDLE ||\n                animatedScrollableType.value === SCROLLABLE_TYPE.VIEW) &&\n              draggedPosition < highestSnapPoint\n            ) {\n              const resistedPosition =\n                highestSnapPoint -\n                Math.sqrt(1 + (highestSnapPoint - draggedPosition)) *\n                  overDragResistanceFactor;\n              animatedPosition.value = resistedPosition;\n              return;\n            }\n\n            if (\n              source === GESTURE_SOURCE.HANDLE &&\n              draggedPosition > lowestSnapPoint\n            ) {\n              const resistedPosition =\n                lowestSnapPoint +\n                Math.sqrt(1 + (draggedPosition - lowestSnapPoint)) *\n                  overDragResistanceFactor;\n              animatedPosition.value = resistedPosition;\n              return;\n            }\n\n            if (\n              source === GESTURE_SOURCE.SCROLLABLE &&\n              draggedPosition + negativeScrollableContentOffset >\n                lowestSnapPoint\n            ) {\n              const resistedPosition =\n                lowestSnapPoint +\n                Math.sqrt(\n                  1 +\n                    (draggedPosition +\n                      negativeScrollableContentOffset -\n                      lowestSnapPoint)\n                ) *\n                  overDragResistanceFactor;\n              animatedPosition.value = resistedPosition;\n              return;\n            }\n          }\n\n          animatedPosition.value = clampedPosition;\n        },\n        [\n          enableOverDrag,\n          enablePanDownToClose,\n          overDragResistanceFactor,\n          isInTemporaryPosition,\n          isScrollableRefreshable,\n          animatedHighestSnapPoint,\n          animatedContainerHeight,\n          animatedSnapPoints,\n          animatedPosition,\n          animatedScrollableType,\n          animatedScrollableContentOffsetY,\n        ]\n      );\n    const handleOnEnd: GestureEventHandlerCallbackType<GestureEventContextType> =\n      useWorkletCallback(\n        function handleOnEnd(\n          source,\n          { translationY, absoluteY, velocityY },\n          context\n        ) {\n          const highestSnapPoint = animatedHighestSnapPoint.value;\n          const isSheetAtHighestSnapPoint =\n            animatedPosition.value === highestSnapPoint;\n\n          /**\n           * if scrollable is refreshable and sheet position at the highest\n           * point, then do not interact with current gesture.\n           */\n          if (\n            source === GESTURE_SOURCE.SCROLLABLE &&\n            isScrollableRefreshable.value &&\n            isSheetAtHighestSnapPoint\n          ) {\n            return;\n          }\n\n          /**\n           * if the sheet is in a temporary position and the gesture ended above\n           * the current position, then we snap back to the temporary position.\n           */\n          if (\n            isInTemporaryPosition.value &&\n            context.initialPosition >= animatedPosition.value\n          ) {\n            if (context.initialPosition > animatedPosition.value) {\n              animateToPosition(\n                context.initialPosition,\n                ANIMATION_SOURCE.GESTURE,\n                velocityY / 2\n              );\n            }\n            return;\n          }\n\n          /**\n           * close keyboard if current position is below the recorded\n           * start position and keyboard still shown.\n           */\n          const isScrollable =\n            animatedScrollableType.value !== SCROLLABLE_TYPE.UNDETERMINED &&\n            animatedScrollableType.value !== SCROLLABLE_TYPE.VIEW;\n\n          /**\n           * if keyboard is shown and the sheet is dragged down,\n           * then we dismiss the keyboard.\n           */\n          if (\n            context.initialKeyboardState === KEYBOARD_STATE.SHOWN &&\n            animatedPosition.value > context.initialPosition\n          ) {\n            /**\n             * if the platform is ios, current content is scrollable and\n             * the end touch point is below the keyboard position then\n             * we exit the method.\n             *\n             * because the the keyboard dismiss is interactive in iOS.\n             */\n            if (\n              !(\n                Platform.OS === 'ios' &&\n                isScrollable &&\n                absoluteY > WINDOW_HEIGHT - animatedKeyboardHeight.value\n              )\n            ) {\n              runOnJS(dismissKeyboard)();\n            }\n          }\n\n          /**\n           * reset isInTemporaryPosition value\n           */\n          if (isInTemporaryPosition.value) {\n            isInTemporaryPosition.value = false;\n          }\n\n          /**\n           * clone snap points array, and insert the container height\n           * if pan down to close is enabled.\n           */\n          const snapPoints = animatedSnapPoints.value.slice();\n          if (enablePanDownToClose) {\n            snapPoints.unshift(animatedClosedPosition.value);\n          }\n\n          /**\n           * calculate the destination point, using redash.\n           */\n          const destinationPoint = snapPoint(\n            translationY + context.initialPosition,\n            velocityY,\n            snapPoints\n          );\n\n          /**\n           * if destination point is the same as the current position,\n           * then no need to perform animation.\n           */\n          if (destinationPoint === animatedPosition.value) {\n            return;\n          }\n\n          const wasGestureHandledByScrollView =\n            source === GESTURE_SOURCE.SCROLLABLE &&\n            animatedScrollableContentOffsetY.value > 0;\n          /**\n           * prevents snapping from top to middle / bottom with repeated interrupted scrolls\n           */\n          if (wasGestureHandledByScrollView && isSheetAtHighestSnapPoint) {\n            return;\n          }\n\n          animateToPosition(\n            destinationPoint,\n            ANIMATION_SOURCE.GESTURE,\n            velocityY / 2\n          );\n        },\n        [\n          enablePanDownToClose,\n          isInTemporaryPosition,\n          isScrollableRefreshable,\n          animatedClosedPosition,\n          animatedHighestSnapPoint,\n          animatedKeyboardHeight,\n          animatedPosition,\n          animatedScrollableType,\n          animatedSnapPoints,\n          animatedScrollableContentOffsetY,\n          animateToPosition,\n        ]\n      );\n    //#endregion\n\n    return {\n      handleOnStart,\n      handleOnActive,\n      handleOnEnd,\n    };\n  };\n"]}