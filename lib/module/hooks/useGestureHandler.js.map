{"version":3,"sources":["useGestureHandler.ts"],"names":["useAnimatedGestureHandler","State","GESTURE_SOURCE","resetContext","context","Object","keys","map","key","undefined","useGestureHandler","type","state","gestureSource","handleOnStart","handleOnActive","handleOnEnd","gestureHandler","onActive","payload","didStart","value","BEGAN","onEnd","UNDETERMINED","onCancel","onFail","onFinish"],"mappings":"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","sourcesContent":["import Animated, { useAnimatedGestureHandler } from 'react-native-reanimated';\nimport {\n  State,\n  PanGestureHandlerGestureEvent,\n} from 'react-native-gesture-handler';\nimport { GESTURE_SOURCE } from '../constants';\nimport type {\n  GestureEventContextType,\n  GestureEventHandlerCallbackType,\n} from '../types';\n\nconst resetContext = (context: any) => {\n  'worklet';\n\n  Object.keys(context).map(key => {\n    context[key] = undefined;\n  });\n};\n\nexport const useGestureHandler = (\n  type: GESTURE_SOURCE,\n  state: Animated.SharedValue<State>,\n  gestureSource: Animated.SharedValue<GESTURE_SOURCE>,\n  handleOnStart: GestureEventHandlerCallbackType,\n  handleOnActive: GestureEventHandlerCallbackType,\n  handleOnEnd: GestureEventHandlerCallbackType\n): ((event: PanGestureHandlerGestureEvent) => void) => {\n  const gestureHandler = useAnimatedGestureHandler<\n    PanGestureHandlerGestureEvent,\n    GestureEventContextType\n  >(\n    {\n      onActive: (payload, context) => {\n        if (!context.didStart) {\n          context.didStart = true;\n\n          state.value = State.BEGAN;\n          gestureSource.value = type;\n\n          handleOnStart(type, payload, context);\n          return;\n        }\n\n        if (gestureSource.value !== type) {\n          return;\n        }\n\n        state.value = payload.state;\n        handleOnActive(type, payload, context);\n      },\n      onEnd: (payload, context) => {\n        if (gestureSource.value !== type) {\n          return;\n        }\n\n        state.value = payload.state;\n        gestureSource.value = GESTURE_SOURCE.UNDETERMINED;\n\n        handleOnEnd(type, payload, context);\n        resetContext(context);\n      },\n      onCancel: (payload, context) => {\n        if (gestureSource.value !== type) {\n          return;\n        }\n\n        state.value = payload.state;\n        gestureSource.value = GESTURE_SOURCE.UNDETERMINED;\n\n        resetContext(context);\n      },\n      onFail: (payload, context) => {\n        if (gestureSource.value !== type) {\n          return;\n        }\n\n        state.value = payload.state;\n        gestureSource.value = GESTURE_SOURCE.UNDETERMINED;\n\n        resetContext(context);\n      },\n      onFinish: (payload, context) => {\n        if (gestureSource.value !== type) {\n          return;\n        }\n\n        state.value = payload.state;\n        gestureSource.value = GESTURE_SOURCE.UNDETERMINED;\n\n        resetContext(context);\n      },\n    },\n    [type, state, handleOnStart, handleOnActive, handleOnEnd]\n  );\n  return gestureHandler;\n};\n"]}