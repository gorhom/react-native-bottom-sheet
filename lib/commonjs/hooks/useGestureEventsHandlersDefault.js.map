{"version":3,"sources":["useGestureEventsHandlersDefault.tsx"],"names":["dismissKeyboard","Keyboard","dismiss","useGestureEventsHandlersDefault","animatedPosition","animatedSnapPoints","animatedKeyboardState","animatedKeyboardHeight","animatedContainerHeight","animatedScrollableType","animatedHighestSnapPoint","animatedClosedPosition","animatedScrollableContentOffsetY","enableOverDrag","enablePanDownToClose","overDragResistanceFactor","isInTemporaryPosition","isScrollableRefreshable","animateToPosition","stopAnimation","handleOnStart","__","_","context","initialPosition","value","initialKeyboardState","isScrollablePositionLocked","handleOnActive","source","translationY","highestSnapPoint","KEYBOARD_STATE","SHOWN","lowestSnapPoint","GESTURE_SOURCE","SCROLLABLE","negativeScrollableContentOffset","draggedPosition","accumulatedDraggedPosition","clampedPosition","HANDLE","SCROLLABLE_TYPE","VIEW","resistedPosition","Math","sqrt","handleOnEnd","absoluteY","velocityY","isSheetAtHighestSnapPoint","ANIMATION_SOURCE","GESTURE","isScrollable","UNDETERMINED","Platform","OS","WINDOW_HEIGHT","snapPoints","slice","unshift","destinationPoint","wasGestureHandledByScrollView"],"mappings":"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","sourcesContent":["import { Keyboard, Platform } from 'react-native';\nimport { runOnJS, useWorkletCallback } from 'react-native-reanimated';\nimport { useBottomSheetInternal } from './useBottomSheetInternal';\nimport {\n  ANIMATION_SOURCE,\n  GESTURE_SOURCE,\n  KEYBOARD_STATE,\n  SCROLLABLE_TYPE,\n  WINDOW_HEIGHT,\n} from '../constants';\nimport type {\n  GestureEventsHandlersHookType,\n  GestureEventHandlerCallbackType,\n} from '../types';\nimport { clamp } from '../utilities/clamp';\nimport { snapPoint } from '../utilities/snapPoint';\n\ntype GestureEventContextType = {\n  initialPosition: number;\n  initialKeyboardState: KEYBOARD_STATE;\n  isScrollablePositionLocked: boolean;\n};\n\nconst dismissKeyboard = Keyboard.dismiss;\n\nexport const useGestureEventsHandlersDefault: GestureEventsHandlersHookType =\n  () => {\n    //#region variables\n    const {\n      animatedPosition,\n      animatedSnapPoints,\n      animatedKeyboardState,\n      animatedKeyboardHeight,\n      animatedContainerHeight,\n      animatedScrollableType,\n      animatedHighestSnapPoint,\n      animatedClosedPosition,\n      animatedScrollableContentOffsetY,\n      enableOverDrag,\n      enablePanDownToClose,\n      overDragResistanceFactor,\n      isInTemporaryPosition,\n      isScrollableRefreshable,\n      animateToPosition,\n      stopAnimation,\n    } = useBottomSheetInternal();\n    //#endregion\n\n    //#region gesture methods\n    const handleOnStart: GestureEventHandlerCallbackType<GestureEventContextType> =\n      useWorkletCallback(\n        function handleOnStart(__, _, context) {\n          // cancel current animation\n          stopAnimation();\n\n          // store current animated position\n          context.initialPosition = animatedPosition.value;\n          context.initialKeyboardState = animatedKeyboardState.value;\n\n          /**\n           * if the scrollable content is scrolled, then\n           * we lock the position.\n           */\n          if (animatedScrollableContentOffsetY.value > 0) {\n            context.isScrollablePositionLocked = true;\n          }\n        },\n        [\n          stopAnimation,\n          animatedPosition,\n          animatedKeyboardState,\n          animatedScrollableContentOffsetY,\n        ]\n      );\n    const handleOnActive: GestureEventHandlerCallbackType<GestureEventContextType> =\n      useWorkletCallback(\n        function handleOnActive(source, { translationY }, context) {\n          let highestSnapPoint = animatedHighestSnapPoint.value;\n\n          /**\n           * if keyboard is shown, then we set the highest point to the current\n           * position which includes the keyboard height.\n           */\n          if (\n            isInTemporaryPosition.value &&\n            context.initialKeyboardState === KEYBOARD_STATE.SHOWN\n          ) {\n            highestSnapPoint = context.initialPosition;\n          }\n\n          /**\n           * if current position is out of provided `snapPoints` and smaller then\n           * highest snap pont, then we set the highest point to the current position.\n           */\n          if (\n            isInTemporaryPosition.value &&\n            context.initialPosition < highestSnapPoint\n          ) {\n            highestSnapPoint = context.initialPosition;\n          }\n\n          const lowestSnapPoint = enablePanDownToClose\n            ? animatedContainerHeight.value\n            : animatedSnapPoints.value[0];\n\n          /**\n           * if scrollable is refreshable and sheet position at the highest\n           * point, then do not interact with current gesture.\n           */\n          if (\n            source === GESTURE_SOURCE.SCROLLABLE &&\n            isScrollableRefreshable.value &&\n            animatedPosition.value === highestSnapPoint\n          ) {\n            return;\n          }\n\n          /**\n           * a negative scrollable content offset to be subtracted from accumulated\n           * current position and gesture translation Y to allow user to drag the sheet,\n           * when scrollable position at the top.\n           * a negative scrollable content offset when the scrollable is not locked.\n           */\n          const negativeScrollableContentOffset =\n            (context.initialPosition === highestSnapPoint &&\n              source === GESTURE_SOURCE.SCROLLABLE) ||\n            !context.isScrollablePositionLocked\n              ? animatedScrollableContentOffsetY.value * -1\n              : 0;\n\n          /**\n           * an accumulated value of starting position with gesture translation y.\n           */\n          const draggedPosition = context.initialPosition + translationY;\n\n          /**\n           * an accumulated value of dragged position and negative scrollable content offset,\n           * this will insure locking sheet position when user is scrolling the scrollable until,\n           * they reach to the top of the scrollable.\n           */\n          const accumulatedDraggedPosition =\n            draggedPosition + negativeScrollableContentOffset;\n\n          /**\n           * a clamped value of the accumulated dragged position, to insure keeping the dragged\n           * position between the highest and lowest snap points.\n           */\n          const clampedPosition = clamp(\n            accumulatedDraggedPosition,\n            highestSnapPoint,\n            lowestSnapPoint\n          );\n\n          /**\n           * if scrollable position is locked and the animated position\n           * reaches the highest point, then we unlock the scrollable position.\n           */\n          if (\n            context.isScrollablePositionLocked &&\n            source === GESTURE_SOURCE.SCROLLABLE &&\n            animatedPosition.value === highestSnapPoint\n          ) {\n            context.isScrollablePositionLocked = false;\n          }\n\n          /**\n           * over-drag implementation.\n           */\n          if (enableOverDrag) {\n            if (\n              (source === GESTURE_SOURCE.HANDLE ||\n                animatedScrollableType.value === SCROLLABLE_TYPE.VIEW) &&\n              draggedPosition < highestSnapPoint\n            ) {\n              const resistedPosition =\n                highestSnapPoint -\n                Math.sqrt(1 + (highestSnapPoint - draggedPosition)) *\n                  overDragResistanceFactor;\n              animatedPosition.value = resistedPosition;\n              return;\n            }\n\n            if (\n              source === GESTURE_SOURCE.HANDLE &&\n              draggedPosition > lowestSnapPoint\n            ) {\n              const resistedPosition =\n                lowestSnapPoint +\n                Math.sqrt(1 + (draggedPosition - lowestSnapPoint)) *\n                  overDragResistanceFactor;\n              animatedPosition.value = resistedPosition;\n              return;\n            }\n\n            if (\n              source === GESTURE_SOURCE.SCROLLABLE &&\n              draggedPosition + negativeScrollableContentOffset >\n                lowestSnapPoint\n            ) {\n              const resistedPosition =\n                lowestSnapPoint +\n                Math.sqrt(\n                  1 +\n                    (draggedPosition +\n                      negativeScrollableContentOffset -\n                      lowestSnapPoint)\n                ) *\n                  overDragResistanceFactor;\n              animatedPosition.value = resistedPosition;\n              return;\n            }\n          }\n\n          animatedPosition.value = clampedPosition;\n        },\n        [\n          enableOverDrag,\n          enablePanDownToClose,\n          overDragResistanceFactor,\n          isInTemporaryPosition,\n          isScrollableRefreshable,\n          animatedHighestSnapPoint,\n          animatedContainerHeight,\n          animatedSnapPoints,\n          animatedPosition,\n          animatedScrollableType,\n          animatedScrollableContentOffsetY,\n        ]\n      );\n    const handleOnEnd: GestureEventHandlerCallbackType<GestureEventContextType> =\n      useWorkletCallback(\n        function handleOnEnd(\n          source,\n          { translationY, absoluteY, velocityY },\n          context\n        ) {\n          const highestSnapPoint = animatedHighestSnapPoint.value;\n          const isSheetAtHighestSnapPoint =\n            animatedPosition.value === highestSnapPoint;\n\n          /**\n           * if scrollable is refreshable and sheet position at the highest\n           * point, then do not interact with current gesture.\n           */\n          if (\n            source === GESTURE_SOURCE.SCROLLABLE &&\n            isScrollableRefreshable.value &&\n            isSheetAtHighestSnapPoint\n          ) {\n            return;\n          }\n\n          /**\n           * if the sheet is in a temporary position and the gesture ended above\n           * the current position, then we snap back to the temporary position.\n           */\n          if (\n            isInTemporaryPosition.value &&\n            context.initialPosition >= animatedPosition.value\n          ) {\n            if (context.initialPosition > animatedPosition.value) {\n              animateToPosition(\n                context.initialPosition,\n                ANIMATION_SOURCE.GESTURE,\n                velocityY / 2\n              );\n            }\n            return;\n          }\n\n          /**\n           * close keyboard if current position is below the recorded\n           * start position and keyboard still shown.\n           */\n          const isScrollable =\n            animatedScrollableType.value !== SCROLLABLE_TYPE.UNDETERMINED &&\n            animatedScrollableType.value !== SCROLLABLE_TYPE.VIEW;\n\n          /**\n           * if keyboard is shown and the sheet is dragged down,\n           * then we dismiss the keyboard.\n           */\n          if (\n            context.initialKeyboardState === KEYBOARD_STATE.SHOWN &&\n            animatedPosition.value > context.initialPosition\n          ) {\n            /**\n             * if the platform is ios, current content is scrollable and\n             * the end touch point is below the keyboard position then\n             * we exit the method.\n             *\n             * because the the keyboard dismiss is interactive in iOS.\n             */\n            if (\n              !(\n                Platform.OS === 'ios' &&\n                isScrollable &&\n                absoluteY > WINDOW_HEIGHT - animatedKeyboardHeight.value\n              )\n            ) {\n              runOnJS(dismissKeyboard)();\n            }\n          }\n\n          /**\n           * reset isInTemporaryPosition value\n           */\n          if (isInTemporaryPosition.value) {\n            isInTemporaryPosition.value = false;\n          }\n\n          /**\n           * clone snap points array, and insert the container height\n           * if pan down to close is enabled.\n           */\n          const snapPoints = animatedSnapPoints.value.slice();\n          if (enablePanDownToClose) {\n            snapPoints.unshift(animatedClosedPosition.value);\n          }\n\n          /**\n           * calculate the destination point, using redash.\n           */\n          const destinationPoint = snapPoint(\n            translationY + context.initialPosition,\n            velocityY,\n            snapPoints\n          );\n\n          /**\n           * if destination point is the same as the current position,\n           * then no need to perform animation.\n           */\n          if (destinationPoint === animatedPosition.value) {\n            return;\n          }\n\n          const wasGestureHandledByScrollView =\n            source === GESTURE_SOURCE.SCROLLABLE &&\n            animatedScrollableContentOffsetY.value > 0;\n          /**\n           * prevents snapping from top to middle / bottom with repeated interrupted scrolls\n           */\n          if (wasGestureHandledByScrollView && isSheetAtHighestSnapPoint) {\n            return;\n          }\n\n          animateToPosition(\n            destinationPoint,\n            ANIMATION_SOURCE.GESTURE,\n            velocityY / 2\n          );\n        },\n        [\n          enablePanDownToClose,\n          isInTemporaryPosition,\n          isScrollableRefreshable,\n          animatedClosedPosition,\n          animatedHighestSnapPoint,\n          animatedKeyboardHeight,\n          animatedPosition,\n          animatedScrollableType,\n          animatedSnapPoints,\n          animatedScrollableContentOffsetY,\n          animateToPosition,\n        ]\n      );\n    //#endregion\n\n    return {\n      handleOnStart,\n      handleOnActive,\n      handleOnEnd,\n    };\n  };\n"]}